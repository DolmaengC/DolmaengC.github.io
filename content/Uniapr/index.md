---
emoji: 🧢
title: Fast and Precise On-the-fly Patch Validation for All
date: '2023-07-22 02:00:00'
author: DolmaengC
tags: APR bytecode
categories: APR bytecode
---

### CITES

Chen, L., Ouyang, Y., & Zhang, L. (2021, May). Fast and precise on-the-fly patch validation for all. In *2021 IEEE/ACM 43rd International Conference on Software Engineering (ICSE)* (pp. 1123-1134). IEEE.



### KEYWORDS

Program repair, Program transformation, Runtime optimization, JVM bytecode manipulation



### ABSTRACT

Generate-and-validate (G&V) automated program repair (APR) 기술은 지난 10년간 널리 연구되었다. 

한편, 그러한 기술은 많은 수의 패치를 만들고 잠재적 수정을 확인하기 위한 패치 테스트하기 위한 실행들 때문에 많은 시간이 걸린다.

최근 G&V APR 기술인 PraPR은 프로그램 코드를 컴파일된 바이트코드 레벨로 바꿔서 코스트를 줄이고, 동일한 JVM 세션 내에서 여러 패치를 테스트할 수 있도록 하여 즉시 패칭을 추가로 수행하게 한다.

하지만, PraPR은 패턴 기반, 바이트코드 레벨의 특성으로 인해 제한적이며 패치 실행이 글로벌 JVM 상태를 변경하지 않고, 동일한 JVM 세션에서 이후 패치 실행에 영향을 미친다고 가정하므로 기본적으로 불건전/부정확하다.

PraPR 작업에서 영감을 받아 UniAPR이라는 통합 패치 유효성 검사 프레임워크를 제안한다. 즉석 패칭을 통해 바이트코드 및 소스 코드 APR 모두에 대한 패치 유효성 검사 속도를 높이는 것을 목표로 한다. 또한 UniAPR은 런타임 바이트코드 변환을 통해 JVM 전역 상태를 재설정하여 부정확한 패치 유효성 검사 문제를 해결한다.

우리는 완전히 자동화된 메이븐 플러그인으로 UniAPR을 구현했다. 우리는 또한 최신 소스 코드 레벨 APR을 위한 즉성 패치 확인의 첫 번째 연구이다.

우리의 실험은 바닐라 즉성 패치 유효성 검사가 부정확/불건전할 수 있다는 최초의 경험적 증거를 보여준다.

대조적으로, 우리의 UniAPR 프레임워크는 패치 유효성 검사에서 부정확성을 초래하지 않고 최신 APR의 속도를 10배 이상 높일 수 있으므로 가까운 미래에 기존의 모든 APR 기술이 더 큰 검색 공간을 탐색하여 더 많은 버그를 수정할 수 있다. 

게다가, UniAPR은 하이브리드 소스 및 바이트코드 APR이 가까운 미래에 모든 최신 APR 기술(동일한 시간 제한 하에서)보다  훨씬 더 많은 버그를 수정할 수 있도록 직접 지원한다. 



### INTRODUCTION

테스트 기반 G&V APR 기술과 관련된 두 가지 주요 비용은 다음과 같습니다. 

(1) 특정 변환 규칙에 따라 패치를 제조/생성하기 위해 프로그램 코드를 조작하는 비용 

(2) 수정 중인 버그에 대한 그럴듯한 패치를 식별하기 위해 모든 개발자 테스트를 반복적으로 실행합니다. 

APR에 대한 검색 공간이 무한하고 이론적 한계로 인해 이 검색 공간의 요소를 분류하는 것이 불가능하기 때문에 테스트 기반 G&V APR 기술은 일반적으로 명확한 지침이 부족하고 거의 무차별 대입 방식으로 작동합니다. 유효성을 검사할 패치 풀과 프로그램이 클수록 생성하고 유효성을 검사할 패치 세트도 커집니다. 이는 패치 생성 및 검증 속도가 APR 기법의 확장성에 중요한 역할을 함을 시사하며, 이는 실제 APR 기법을 설계하는 데 있어 가장 중요한 과제 중 하나이다[9]. 따라서 새롭고 보다 효과적인 변환 규칙을 도입하는 것 외에도 앞서 언급한 비용을 완화하기 위해 일부 APR 기술이 제안되었습니다. 예를 들어 JAID[6]는 변형 스키마를 사용하여 단일 소스 파일에 여러 패치를 묶는 메타 프로그램을 제작하는 반면 SketchFix[17]는 스케치[28]를 사용하여 유사한 효과를 얻습니다. 그러나 이러한 기술은 주로 패치 생성 시간을 단축하는 것을 목표로 하는 반면 패치 유효성 검사 시간은 APR 동안 지배적인 것으로 나타났습니다[42]. 가장 최근에 PraPR[14]은 패치 생성 및 유효성 검사 시간을 모두 줄이는 것을 목표로 합니다. 컴파일된 JVM 바이트코드 수준에서 프로그램 코드를 직접 수정하여 패치 생성 비용을 줄이고 비용이 많이 드는 프로세스인 패치 간에 JVM(Java Virtual Machine) 세션 재사용을 통한 생성/초기화를 피함으로써 패치 유효성 검사 비용을 줄입니다. 

PraPR이 효과적이긴 하지만 2가지 주요한 문제가 있다.

1. 바이트코드의 성질로 인해 유연하지 않다.
2. 부정확한 패치 확인 결과로 인해 안전하지 않다.

UniAPR은 모든 바이트코드 혹은 소스코드 레벨의 APR기술들을 위한 불필요한 JVM 재시작을 피함으로써 패치 확인 비용을 줄이는 결합된 테스트 기반 패치 확인 프레임워크이다.



### APPROACH

##### Overview

<img width="875" alt="스크린샷 2023-01-12 오전 10 14 02" src="https://user-images.githubusercontent.com/107832431/212212894-15147d7b-d1b0-43fa-9304-05dace8bae25.png">


1. UniAPR은 먼저 기존 APR 도구를 활용하여 소스코드 레벨 패치를 만든다(❶). 

2. UniAPR이 증분 컴파일을 수행하여 각 패치별로 패치된 소스 파일을 바이트코드 파일로 컴파일한다(❷).

   - UniAPR은 융합된 프레임워크이다

   - UniAPR은 PraPR같은 바이트코드 APR기술을 통해 직접적으로 바이트코드를 얻을 수도 있다.

   - 이 방법으로 UniAPR은 패치 확인을 위한 바이트코드 패치 풀을 가진다.

3. 실제 패치 확인동안, UniAPR은 먼저 전체 버기 프로젝트를 바이트코드 파일로 컴파일한다(❸).
4. 그런 다음 모든 바이트코드 파일을 JVM 클래스 로더를 통해 JVM으로 로드한다(❹).
   - 이 두 단계는 버기 프로젝트에 대한 원래 테스트를 실행하는 것과 정확히 동일하다.
5. 원래 프로젝트의 모든 바이트코드 파일이 JVM 내에 로드되기 때문에 각 패치의 유효성을 검사하기 위해 UniAPR은 ❺로 표시된 Java Agent 기술 및 HotSpot 메커니즘을 통해 특정 패치에 의해 패치된 바이트코드 파일만 다시 로드한다.
6. 그 후, 테스트 드라이버를 실행하여 새로운 JVM을 재시작하지 않고 패치 확일을 위한 테스트를 실행할 수 있다.
7. 이 패치 실행에 대한 모든 테스트가 완료된 후 UniAPR은 패치된 바이트코드 파일을 원래 버전으로 되돌리기 위해 원래 파일로 교체한다.
8. 또한 UniAPR은 전역 JVM 상태를 재설정하여 다음 패치 실행을 위해 깨끗한 JVM 환경을 준비한다.(짧은 점선)
   - 모든 패치에 동일한 과정이 반복된다.
9. 마지막으로 패치 실행 결과는 소캣 연결을 통해 패치 실행 데이터베이스에 저장된다(❻).
   -  모든 테스트를 통과한 패치를 plausible 패치라 한다.

10. 소스코드 레벨 APR로 만들어진 패치들 중 plausible 패치인 경우 수동 검사를 위해 원본 소스코드 레벨 패치를 직접 검색한다.





##### Fast Patch Valudation via On-the-fly Patching

<img width="527" alt="스크린샷 2023-01-13 오후 3 01 09" src="https://user-images.githubusercontent.com/107832431/212248622-d88f8dd9-06aa-483b-a3a4-d6ee4869d704.png">















 <Utterances repo='DolmaengC/DolmaengC.github.io' path="path" />